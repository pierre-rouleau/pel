;;; pel-skels.el --- Base code skeleton utilities  -*- lexical-binding: t; -*-

;; Copyright (C) 2020, 2021  Pierre Rouleau

;; Author: Pierre Rouleau <prouleau001@gmail.com>

;; This file is part of the PEL package
;; This file is not part of GNU Emacs.

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;; -----------------------------------------------------------------------------
;;; Commentary:
;;
;; This file defines a set of functions used to create code generation tempo
;; skeletons that may be used for several programming and markup languages.
;; These are used in other pel-skel files.
;;
;; The available functions ('-') and variables ('>')  are listed below:
;;
;; - `pel-skel-space-for'
;; - `pel-skel-header'
;; - `pel-skel-skip-blank'
;; - `pel-date'
;; - `pel-skel-time-stamp'
;;   - `pel-time-stamp'
;; - `pel-skel-purpose-for'
;;   >  `pel--skel-last-purpose'
;; - `pel-skel-author-comment'
;;   > `pel-skel-email-address'
;; - `pel-skel-created-comment'
;; - `pel-skel-insert-license-when'
;;   - `pel-license-text'
;; - `pel-skel-copyright-comment'
;; - `pel-skel-call'

;; -----------------------------------------------------------------------------
;;; Dependencies:

(require 'pel--base)                  ; use: pel-line-has-only-whitespace-p
;;                                    ;      pel-string-when
;;                                    ;      pel-ends-with-space-p
(require 'pel--options)               ; use: pel-c-skel-comment-with-2stars
(require 'pel-prompt)                 ; use: pel-prompt-purpose-for
;; -----------------------------------------------------------------------------
;;; Code:

;; --
;; Basic formatting

(defun pel-skel-space-for (string)
  "Return a space string if STRING does not end with a space.
Return an empty string otherwise."
  (pel-string-when (not (pel-ends-with-space-p string)) " "))

(defun pel-skel-header (func)
  "Insert skeleton generated by FUNC at beginning of buffer and goto first mark."
  (goto-char (point-min))
  (save-excursion
    (funcall func))
  (funcall (symbol-function 'tempo-forward-mark)))

(defun pel-skel-skip-blank ()
  "Move back, skip all whitespace, insert nothing."
  (skip-chars-backward " \t")
  nil)

;; --
;; Date and time

;;-pel-autoload
(defun pel-date (&optional utc)
  "Return a YYYY-MM-DD (ISO 8601 conforming) date.
Return a UTC Date Time if UTC is non-nil."
  (if utc
       (format-time-string "%F %T (UTC)" nil t)
     (format-time-string "%F")))

;;-pel-autoload
(defun pel-time-stamp (&optional format-string user-format utc)
  "Return a YYYY-MM-DD HH:MM:SS Emacs compliant time stamp string.

By default the format string is \"Time-stamp: <%s%s>\" unless
specified by the FORMAT-STRING argument.  In both cases the
format string uses the following two string arguments, in the
following order:

- Date/Time format which is in UTC format when the UTC argument
  is non-nil, otherwise it is using local time.
- A format string that describes the user and takes one string argument. It is
  specified by USER-FORMAT, defaulting to \", by %s\".  The string argument is
  filled with the user name, extracted by the function `user-full-name'.
  If USER-FORMAT is specified and is a empty-string, then nothing is inserted
  after the date/time value.

This time stamp will be updated automatically by Emacs on file save
when `pel-update-time-stamp' is non-nil."
  (format (or format-string "Time-stamp: <%s%s>")
          (if utc
              (format-time-string "%F %T (UTC)" nil t)
            (format-time-string "%F %T"))
          (if (and (stringp user-format)
                   (string= user-format ""))
              ""
            (format (or user-format ", by %s")
                    (user-full-name)))))

(defun pel-skel-time-stamp (condition &optional
                                      comment-prefix
                                      format-string
                                      user-format
                                      utc)
  "Return a time stamp string if CONDITION is non-nil.

The string starts with `comment-start' unless COMMENT-PREFIX is
specified, in which case that is used.  If a COMMENT-PREFIX is a
non-empty string a space is placed after it.  If COMMENT-PREFIX
is an empty string, then no space is placed.

By default the format string is \"Time-stamp: <%s%s>\" unless
specified by the FORMAT-STRING argument.  In both cases the
format string uses the following two string arguments, in the
following order:

- Date/Time format which is in UTC format when the UTC argument
  is non-nil, otherwise it is using local time.
- A format string that describes the user and takes one string argument. It is
  specified by USER-FORMAT, defaulting to \", by %s\".  The string argument is
  filled with the user name, extracted by the function `user-full-name'.
  If USER-FORMAT is specified and is a empty-string, then nothing is inserted
  after the date/time value."
  (when condition
    (let* ((used-comment-prefix (or comment-prefix comment-start))
           ;; only use a space after comment string when there is a comment
           ;; string, otherwise don't put an extra space.
           (format-str (if (string= used-comment-prefix "")
                           "%s%s\n"
                         "%s %s\n")))
      (format format-str
              used-comment-prefix
              (pel-time-stamp format-string user-format utc)))))

;; --
;; Purpose

(defvar pel--skel-last-purpose ""
  "Holds last purpose entered by user.
Short lived, used by skel functions.
Set by function `pel-skel-purpose-for' and read by skel sub-functions.
Do NOT modify the value anywhere else!")

(defun pel-skel-purpose-for (get-text item &optional comment-prefix title)
  "Return a tempo skel list describing the purpose of the entry.
Prompt for the purpose when GET-TEXT is non-nil.
ITEM is a string describing the thing whose purpose is described.
This prompts the user for the purpose and inserts the typed string if any,
otherwise it leaves a tempo marker at its place.
The line starts with `comment-start' unless COMMENT-PREFIX is specified,
in which case that is used.
The tag uses TITLE if specified otherwise it uses ITEM capitalized."
  (let* ((purpose     (when get-text (pel-prompt-purpose-for item)))
         (comment-str (or comment-prefix comment-start)))
    (unless purpose
      (setq purpose 'p))
    ;; store entered purpose: it may be placed several times in a skeleton.
    (setq pel--skel-last-purpose purpose)
    (list 'l
          comment-str " " (or title (capitalize item)) " " purpose 'n)))

;; --
;; Author

(defconst pel-skel-email-address
  (if (or (not user-mail-address) (string-match "(" user-mail-address))
      (concat (user-login-name) "@"
              (or (and (boundp 'mail-host-address)
                       mail-host-address)
                  (system-name)))
    user-mail-address)
  "Mail address of the user.")

;;-pel-autoload
(defun pel-skel-author-comment (&optional comment-prefix author-word on-this-line)
  "Return a commented line providing the file's author name.

The line starts with `comment-start' unless COMMENT-PREFIX is
specified, in which case that is used.

The string \"Author    :\" is used unless AUTHOR-WORD is specified, in which
case that is used.  This can be useful for documentation systems such as
Erlang's Edoc, where \"@author\" can be specified.

The author's name follows along with it's email address.
The returned string ends with a newline."
  (let ((auth-word (or author-word "Author    :"))
        (auth-comment (or comment-prefix comment-start)))
    (format "%s%s%s%s %s <%s>\n"
            (if (or on-this-line
                    (pel-line-has-only-whitespace-p)) "" "\n")
            auth-comment
            (if (string= comment-prefix "")
                ""
              " ")
            auth-word
            (user-full-name)
            pel-skel-email-address)))

;; --
;; Created

;;-pel-autoload
(defun pel-skel-created-comment (&optional comment-prefix title on-this-line)
  "Return a \"Created timestamp\" line string.

The line starts with `comment-start' unless COMMENT-PREFIX is
specified, in which case that is used.

The string \"Created   :\" is used unless the TITLE is specified, in which
case that is used. This can be useful for some types of files which have a
specific requirement for some meta fields, such as reStructuredText.

It starts on a new line unless ON-THIS-LINE is non-nil.
The returned string ends with a newline."
  (format "%s%s%s%s %s\n"
          (if (or on-this-line
                  (pel-line-has-only-whitespace-p)) "" "\n")
          (or comment-prefix comment-start)
          (if (string= comment-prefix "")
              ""
            " ")
          (or title "Created   :")
          (format-time-string "%A, %B %e %Y.")))

;; --
;; License

(defun pel-license-text (&optional comment-prefix)
  "Return the license text identified by the function `lice' when used.
If the user-option variable `pel-use-lice' is t, the function `lice'
is used to create a license text, otherwise no license is created.
The line starts with `comment-start' unless COMMENT-PREFIX is specified,
in which case that is used."
  (if (and pel-use-lice
           (require 'lice)
           (fboundp 'lice))
      (let ((the-comment-start (or comment-prefix comment-start)))
        (with-temp-buffer
          (let ((comment-start the-comment-start))
            (call-interactively 'lice)
            (buffer-string))))
    ""))

;;-pel-autoload
(defun pel-skel-insert-license-when (condition &optional comment-prefix)
  "Return a license text when CONDITION is non-nil.
The line starts with `comment-start' unless COMMENT-PREFIX is specified,
in which case that is used."
  (if condition (pel-license-text comment-prefix) "" ))

;; --
;; Copyright & License

;;-pel-autoload
(defun pel-skel-copyright-comment (with-license &optional
                                                comment-prefix
                                                copyright-word
                                                license-word)
  "Return a commented copyright & license adapted to the organization or user.

The copyright is assigned to `*copyright-organization*' if it is bound,
otherwise it is assigned to the value returned by function  `user-full-name'.

The line starts with `comment-start' unless COMMENT-PREFIX is specified,
in which case that is used.

By default the strings \" Copyright ©\" and \" License :\" are
used for their specific lines, unless the COPYRIGHT-WORD and
LICENSE_WORD argument specify another string to use for their
corresponding argument.  Note that the two default strings have
the same length.  It may be useful to replace the default for
some type of files, such as Erlang where \"@copyright\" might be
a good choice and for reStructuredText where \":copyright:\"
markup might be used to create a file meta attribute.

The format of the inserted text is controlled by the argument
WITH-LICENSE:

- nil:             No copyright, no license information is inserted.
- only-copyright:  A copyright notice with user name and date, no
                   license.
- a string:        Insert a copyright notice and licence line, with only the
                   license name specified, not the full license text.
                   The string should be the name of the license type
                   something like \"MIT\" or \"GPL-v3\" or whatever
                   appropriate.
- t:               Insert a copyright notice and the full text of a license.
                   The type of the license is controlled by the function
                   `lice' from the lice package.  If the license type is
                   not specified by lice customization, the function will
                   prompt for the license type.

In the first case, the function returns nil.  In the 3 other cases, it returns
a string that contains the relevant information and ends with a newline
character."
  (let ((cpr-word (or copyright-word " Copyright ©"))
        (cpr-owner (if (boundp '*copyright-organization*)
                       *copyright-organization*
                     (user-full-name)))
        (lic-word (or license-word   " License   :"))
        (comment-str (or comment-prefix comment-start)))
    (cond
     ((eq with-license t)
      (format "\n%s\n"
              (pel-license-text comment-str)))
     ((eq with-license 'only-copyright)
      (format "%s%s%s %s, %s\n"
              (if (pel-line-has-only-whitespace-p) "" "\n")
              comment-str
              cpr-word
              (format-time-string "%Y")
              cpr-owner))
     ((stringp with-license)
      (format "%s%s%s %s, %s\n%s%s %s\n"
              (if (pel-line-has-only-whitespace-p) "" "\n")
              comment-str
              cpr-word
              (format-time-string "%Y")
              cpr-owner
              comment-str
              lic-word
              with-license)))))

;; --
;; Calling skel function specified by user file

(defun pel-skel-call (user-option skel-function &rest args)
  "Return tempo list skeleton taken from user supplied file and function.
- USER-OPTION := symbol of the user option variable that identifies the
                 name of the file to load.
- SKEL-FUNCTION := symbol of the function to execute.
Issue a user-error with explicit message on any error.
The any extra ARGS are arguments passed to SKEL-FUNCTION."
  (let ((fname            (symbol-value user-option))
        (user-option-name (symbol-name user-option)))
    (if (not (file-exists-p fname))
        (user-error "File %s specified in %s does not exist!"
                    fname
                    user-option-name)
      (if (not (load fname :noerror))
          (user-error "Can't load file %s specified in %s!"
                      fname
                      user-option-name)
        (if (not (fboundp skel-function))
            (user-error "Invalid %s function in file %s specified by %s!"
                        (symbol-name skel-function)
                        fname
                        user-option-name)
          ;; all is OK: call the skel-function and pass it his arguments
          ;; if there are any
          (apply skel-function args))))))

(defun pel-lisp-family-major-mode-p ()
  "Return t if the current major mode is for a Lisp-family language.
Return nil otherwise."
  (memq major-mode '(lisp-mode
                     emacs-lisp-mode
                     lfe-mode
                     clojure-mode
                     hy-mode
                     scheme-mode
                     racket-mode)))

(defun pel-skel-comments-strings ()
  "Return a list of 3 strings describing comments.
These 3 strings are:
1- The comment begin string:        comment-start
2- The comment continuation string: comment-continue
3- The comment closing string:      comment-end

The function supports generically all types of files, but also
gives special considerations to the cc programming language (C,
C++...), to Erlang and Lisp-family programming languages.

In the cc (C, C++...) languages where the 3 strings are:

1- The comment start block.  Something like \"/*\" or \"//\".
   It does *not* end with a space.
2- The intermediate comment block.  Something like \"**\", \" *\",
   or  \"//\".
3- The closing comment block.  Something like \"*\", \" */\" or \"\".
The string returned is selected by the currently active C-style.
The following variables are used for the decision:
- variable `c-block-comment-flag'
- variable `pel-c-skel-comment-with-2stars'.

For Lisp-family languages, comments can start with 1, 2, 3, or 4
';' the end-comment is empty.  For Erlang, comments can start
with 1, 2, 3 or 4 '%' and the end-comment is empty.  For those
the function returns a list of strings as the first element of
the returned list.  So for Lisp languages and for Erlang, the
function returns:

1- A list of comment begin strings with the first element being
   the deeper level comment string with only one character like
   \";\" or \"%\", and the next elements have 2 , 3 and 4 characters.
2- The comment continuation string: comment-continue
3- The comment closing string:      comment-end

"
  ;; ensure that comments for the current buffer mode are identified.
  ;; if they are not, prompt the user.
  (pel-require 'newcomment)
  (comment-normalize-vars)
  (let* ((c-style   (and (boundp 'c-block-comment-flag)
                         c-block-comment-flag))
         (cb        (cond
                     ((pel-lisp-family-major-mode-p)
                      '(";" ";;" ";;;" ";;;;"))
                     ((eq major-mode 'erlang-mode)
                      '("%" "%%" "%%%" "%%%%"))
                     (t
                      (if c-style "/*"  comment-start))))
         (cc        (if c-style "**"  (or comment-continue comment-start)))
         (ce        (if c-style "*/"  comment-end)))
    (when (stringp cb)
      (unless pel-c-skel-comment-with-2stars
        ;; use " *" instead of "**" to continue C-style comments
        (when (string= cc "**")
          (setq cc " *"))
        (when (string= ce "*/")
          (setq ce " */")))
      (cond ((and (string= cb "/*")
                  (string= cc " *")
                  (string= ce "*/"))
             (setq ce " */"))
            ((and (string= cb "// ")
                  (string= cc "// "))
             (setq cb "//")
             (setq cc "//"))))
    (list cb cc ce)))

;; -----------------------------------------------------------------------------
(provide 'pel-skels)

;;; pel-skels.el ends here
