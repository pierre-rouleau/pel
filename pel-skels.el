;;; pel-skels.el --- Base code skeleton utilities  -*- lexical-binding: t; -*-

;; Copyright (C) 2020  Pierre Rouleau

;; Author: Pierre Rouleau <prouleau001@gmail.com>

;; This file is part of the PEL package
;; This file is not part of GNU Emacs.

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;; -----------------------------------------------------------------------------
;;; Commentary:
;;
;; This file defines a set of functions used to create code generation tempo
;; skeletons that may be used for several programming and markup languages.
;; These are used in other pel-skel files.


(require 'pel--base)         ; use:  pel-line-only-whitespace-p
(eval-when-compile (require 'subr-x))

;; --
;; Basic formatting

(defun pel-skel-header (func)
  "Insert skeleton generated by FUNC at beginning of buffer and goto first mark."
  (goto-char (point-min))
  (save-excursion
    (funcall func))
  (funcall (symbol-function 'tempo-forward-mark)))

(defun pel-skel-skip-blank ()
  "Move back, skip all whitespace, insert nothing."
  (skip-chars-backward " \t")
  nil)

;; --
;; Tempo-compliant skeleton inclusion

(defun pel-skel-include (&rest forms)
  "Include a tempo template inside another one.
Used like this:
  (defvar fct-skel '(\"%%% Important function:\"
                     (pel-skel-include pel-skel-erlang-func)))

This returns what tempo expects: a list form with the symbol
'l as the first element and the FORMS specified expanded."
  (let (result)
    (dolist (form forms)
      (dolist (elem form)
        (setq result (cons elem result))))
    (cons 'l (nreverse result))))

(defun pel-skel-include-when (option &rest forms)
  "Include a tempo template inside another one.
Used like this:
  (defvar fct-skel '(\"%%% Important function:\"
                     (pel-skel-include-when option
                                          pel-skel-erlang-func)))

This returns what tempo expects: a list form with the symbol
'l as the first element and the FORMS specified expanded.
if OPTION is non-nil otherwise it return nil."
  (when option
    (let (result)
      (dolist (form forms)
        (dolist (elem form)
          (setq result (cons elem result))))
      (cons 'l (nreverse result)))))

;; --
;; Date and time

;;-pel-autoload
(defun pel-date (&optional utc)
  "Return a YYYY-MM-DD (ISO 8601 conforming) date.
Return a UTC Date Time if UTC is non-nil."
  (if utc
       (format-time-string "%F %T (UTC)" nil t)
     (format-time-string "%F")))

;;-pel-autoload
(defun pel-time-stamp (&optional event user-text utc)
  "Return a YYYY-MM-DD HH:MM:SS Emacs compliant time-stamp.
The EVENT (if any) is capitalized and placed before the time stamp.
Use UTC format when UTC is non-nil.
Set USER-TEXT to the a descriptive string like \"by \") to
add that text followed by the full user name.
This time stamp will be updated automatically by Emacs on file save
when `pel-update-time-stamp' is non-nil."
  (format "%sTime-stamp: <%s%s>"
          (if event (capitalize event) "")
          (if utc
              (format-time-string "%F %T (UTC)" nil t)
            (format-time-string "%F %T"))
          (if user-text
              (format ", %s%s"
                      user-text
                      (user-full-name))
            "")))


;; --
;; Purpose

(defun pel-skel-purpose-for (get-text item &optional comment-prefix title)
  "Return a tempo skel list describing the purpose of the entry.
Prompt for the purpose when GET-TEXT is non-nil.
ITEM is a string describing the thing whose purpose is described.
This prompts the user for the purpose and inserts the typed string if any,
otherwise it leaves a tempo marker at its place.
The line starts with `comment-start' unless COMMENT-PREFIX is specified,
in which case that is used.
The tag uses TITLE if specified otherwise it uses ITEM capitalized."
  (let* ((purpose     (if get-text
                          (end-text-with-period
                           (capitalize-first-letter
                            (string-trim
                             (read-from-minibuffer
                              (format "Purpose for %s: " item)))))
                        ""))
         (comment-str (or comment-prefix comment-start))
         (text        (format "%s %s %s"
                              comment-str
                              (or title (capitalize item))
                              purpose)))
    (if (string= purpose "")
        ;; when user did not specify a purpose leave a tempo marker in place.
        (cons 'l (cons text (cons 'p (cons 'n nil))))
      (cons 'l (cons text (cons 'n nil ))))))

;; --
;; Author

(defconst pel-skel-email-address
  (if (or (not user-mail-address) (string-match "(" user-mail-address))
      (concat (user-login-name) "@"
              (or (and (boundp 'mail-host-address)
                       mail-host-address)
                  (system-name)))
    user-mail-address)
  "Mail address of the user.")

;;-pel-autoload
(defun pel-skel-author-comment (&optional comment-prefix author-word)
  "Return a commented line providing the file's author name.
The string \"Author    :\" is used unless AUTHOR-WORD is specified, in which
case that is used. This can be useful for documentation systems such as
Erlang's Edoc, where \"@author\" can be specified.
The author's name follows along with it's email address."
  (let ((auth-word (or author-word "Author    :"))
        (auth-comment (or comment-prefix comment-start)))
    (format "%s%s %s %s <%s>\n"
            (if (pel-line-only-whitespace-p) "" "\n")
            auth-comment
            auth-word
            (user-full-name)
            pel-skel-email-address)))

;; --
;; Created

;;-pel-autoload
(defun pel-skel-created-comment (&optional comment-prefix)
  "Return a Created timestamp line."
  (format "%s%s Created   : %s\n"
          (if (pel-line-only-whitespace-p) "" "\n")
          (or comment-prefix comment-start)
          (format-time-string "%A, %B %e %Y.")))


;; --
;; License

(defun pel-license-text (&optional comment-prefix)
  "Return the license text identified by the function `lice'."
  (if (and (require 'lice)
             (fboundp 'lice))
    (let ((the-comment-start (or comment-prefix comment-start)))
      (with-temp-buffer
        (let ((comment-start the-comment-start))
          (call-interactively 'lice)
          (buffer-string))))
    ""))

;;-pel-autoload
(defun pel-skel-insert-license-when (condition &optional comment-prefix)
  ""
  (if condition (pel-license-text comment-prefix) "" ))

;; --
;; Copyright

;;-pel-autoload
(defun pel-skel-copyright-comment (&optional comment-prefix copyright-word with-license)
  "Return a commented copyright adapted to the organization or user.
The copyright is assigned to `*copyright-organization*' if it is bound,
otherwise it is assigned to the value returned by function  `user-full-name'.
The line starts with `comment-start' unless COMMENT-PREFIX is specified,
in which case that is used.
The word 'Copyright' is used unless COPYRIGHT-WORD is specified, in which
case that is used. It can be useful for documentation systems such as
Erlang Edoc, where \"@copyright\" can be specified.
If WITH-LICENSE is non-nil, license text, controlled by function `lice' is
inserted."
  (let ((cpr-word (or copyright-word "Copyright"))
        (cpr-owner (if (boundp '*copyright-organization*)
                       *copyright-organization*
                     (user-full-name)))
        (cpr-comment (or comment-prefix comment-start)))
    (if with-license
        (format "\n%s\n"
                (pel-license-text cpr-comment))
      (format "%s%s %s (C) %s, %s\n"
              (if (pel-line-only-whitespace-p) "" "\n")
              cpr-comment
              cpr-word
              (format-time-string "%Y")
              cpr-owner))))

;; -----------------------------------------------------------------------------
(provide 'pel-skels)

;;; pel-skels.el ends here
