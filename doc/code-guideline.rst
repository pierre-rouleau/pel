=========================
Emacs Lisp Code Guideline
=========================

This document describes a general code guideline for Emacs Lisp code written
inside this project.

:warning::
           This document is a preliminary version.  It's a *work in progress*.


Basic and Mandatory Rules
=========================


Write code to ease reading and understanding
--------------------------------------------

Code does not exist to help writing it.  It exists to help people read and
understand it.

- Use meaningful names.
- Use appropriate data structures.
- Organize the file layout to help convey the intent of your code.
- Use appropriate and valid docstrings to increase understanding.
  Use links in docstrings to refer to related functions and data element.
- Use appropriate and valid comments when nothing else can help understanding
  the background of the intent of your code.



Do Not Repeat Yourself
----------------------

Adhere to the DRY principle.

Do not duplicate logic.
Do not duplicate declarations and definitions.
Do not duplicate information.

Re-use as much as possible.

**Implications:**

To follow this guideline means that you should not copy-paste code because the
logic is the same, instead conceal that logic inside a function and re-use
that function where you need the logic.

Do not prematurely optimize by duplicating code.  Leave optimization to where
it belongs: towards the end of the development cycle when you can use a
Profiler to identify the code that needs optimizations.


Delete unused code
------------------

- Don't keep stale and unused code.
- Don't keep commented-out code.
- Don't keep invalid comments.
- Don't keep code duplication.

Delete them all from files.

Keep your files clean to help people understand the architecture and the
intent of your code.
Make it easy for yourself and others to spot mistakes.
They will come soon enough.

If you need a sanctuary for old and new thoughts, ideas or candidate for
future prototypes or implementation create separate files in special
directories labelled as such.
In all cases it's best to create special markup files with embedded code
describing your ideas.
Use powerful markups like Org-mode or reStructuredText where you can use
literate programming techniques to describe the ideas you want to keep around
but are not yet ready for inclusion inside our code.


Write descriptive docstring to all forms that accept one
--------------------------------------------------------

Write a docstring that describes the purpose and intent of **every** of the
following forms in your code:

- defun
- defmacro
- defvar
- defconst
- defcustom

Write your docstring to help someone else understand the purpose and intent of
the form.



Code Writing Logic
==================

The following guideline sub-sections apply to Elisp code that writes Elisp
code in files.

Implement logic inside non-interactive functions
------------------------------------------------

Code generation code is meant to be invoked from control scripts, not executed
manually. If you need to invoke it manually you can use Emacs various
facilities to do so:

- Write invoking code inside a buffer or a file and execute it with the
  various available commands using C-x C-e or C-j.
- Use M-: and type the expression at the prompt.
- Use IELM shell and invoke the function.

The advantages of doing so is that you will increase your understanding of the
API provided by your functions, and will identify problems with your design
sooner.




Prefer Passing Arguments to Using Global Variables
--------------------------------------------------


Writing Conditionals
====================

Prefer using when instead of and
--------------------------------

For conditional forms prefer using the ``when`` form instead of cascaded
``and`` forms.
This clarifies the code intent.

The generated byte-compiled code is the same; there is no penalty to use the
``when`` form.

As an example, take the following code:

.. code:: lisp

    (defun maybe-store-value (value)
      "Store VALUE if conditions are met."
      (and (not py-error) value (or py-debug-p py-store-result-p) (kill-new value)))

Prefer writing the above function with a ``when`` form:

.. code:: lisp

    (defun maybe-store-value (string)
      "Store STRING if conditions are met."
      (when (and (not py-error)
                 string
                 (or py-debug-p py-store-result-p))
           (kill-new string)))

Both of these implementations produce the same byte code::

    byte code for py--store-result-maybe:
      doc:  Store VALUE if conditions are met. ...
      args: (arg1)
    0       varref    py-error
    1       not
    2       goto-if-nil-else-pop 2
    5       dup
    6       goto-if-nil-else-pop 2
    9       varref    py-debug-p
    10      goto-if-not-nil 1
    13      varref    py-store-result-p
    14      goto-if-nil-else-pop 2
    17:1    constant  kill-new
    18      stack-ref 1
    19      call      1
    20:2    return



.. ---------------------------------------------------------------------------

..  LocalWords:  defun defmacro defvar defconst defcustom
